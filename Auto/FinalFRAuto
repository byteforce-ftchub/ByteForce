package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.Servo;

@Autonomous(name = "FRAuto", group = "Auto")
public class FRAuto extends LinearOpMode {

    // Drive motors
    private DcMotor frontLeft, frontRight, backLeft, backRight;

    // Mechanism motors
    private DcMotor outtake, outtake2, intake, ramp;

    // Servo for blocker
    private Servo blocker;

    @Override
    public void runOpMode() {

        // Map all hardware motors/servos
        frontLeft  = hardwareMap.get(DcMotor.class, "frontLeft");
        frontRight = hardwareMap.get(DcMotor.class, "frontRight");
        backLeft   = hardwareMap.get(DcMotor.class, "backLeft");
        backRight  = hardwareMap.get(DcMotor.class, "backRight");

        outtake  = hardwareMap.get(DcMotor.class, "outtake");
        outtake2 = hardwareMap.get(DcMotor.class, "outtake2");
        intake   = hardwareMap.get(DcMotor.class, "intake");
        ramp     = hardwareMap.get(DcMotor.class, "ramp");

        blocker  = hardwareMap.get(Servo.class, "blocker");

        // Reverse motors so robot drives correctly
        frontLeft.setDirection(DcMotor.Direction.REVERSE);
        backLeft.setDirection(DcMotor.Direction.REVERSE);
        intake.setDirection(DcMotor.Direction.REVERSE);
        outtake.setDirection(DcMotor.Direction.REVERSE);
        outtake2.setDirection(DcMotor.Direction.REVERSE);

        // Reset encoders used for movement tracking
        resetOdo();

        waitForStart();

        if (opModeIsActive()) {
            intake.setPower(1.0);

            // --- PRELOAD DUMP ---
            outtake.setPower(0.7);
            outtake2.setPower(0.7);
            blocker.setPosition(0.9);   // open blocker

            strafeLeftTicks(39000, 0.8);
            sleep(1000);
            moveForwardTicks(1000, 0.5);
            sleep(2000);

            ramp.setPower(0.9);         // run ramp
            sleep(4000);            // End auto

            strafeRightTicks(30000,1);
            stopDrive();
        }
    }

    // Reset encoders used as “odometers”
    private void resetOdo() {
        intake.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        outtake.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        ramp.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);

        intake.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        outtake.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        ramp.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
    }

    // Stop all drive motors
    private void stopDrive() {
        frontLeft.setPower(0);
        backLeft.setPower(0);
        frontRight.setPower(0);
        backRight.setPower(0);
    }

    // Drive backward for encoder distance
    private void moveBackTicks(int target, double power) {
        resetOdo();
        while (opModeIsActive() && Math.abs(intake.getCurrentPosition()) < target) {
            frontLeft.setPower(-power);
            backLeft.setPower(-power);
            frontRight.setPower(-power);
            backRight.setPower(-power);
        }
        stopDrive();
    }

    // Turn right in place
    private void turnRightTicks(int target, double power) {
        resetOdo();
        while (opModeIsActive() && Math.abs(outtake.getCurrentPosition()) < target) {
            frontLeft.setPower(power);
            backLeft.setPower(power);
            frontRight.setPower(-power);
            backRight.setPower(-power);
        }
        stopDrive();
    }

    // Turn left in place
    private void turnLeftTicks(int target, double power) {
        resetOdo();
        while (opModeIsActive() && Math.abs(outtake.getCurrentPosition()) < target) {
            frontLeft.setPower(-power);
            backLeft.setPower(-power);
            frontRight.setPower(power);
            backRight.setPower(power);
        }
        stopDrive();
    }

    // Strafe right (mecanum wheels)
    private void strafeRightTicks(int target, double power) {
        resetOdo();
        while (opModeIsActive() && Math.abs(ramp.getCurrentPosition()) < target) {
            frontLeft.setPower(power);
            backLeft.setPower(-power);
            frontRight.setPower(-power);
            backRight.setPower(power);
        }
        stopDrive();
    }

    // Strafe left
    private void strafeLeftTicks(int target, double power) {
        resetOdo();
        while (opModeIsActive() && Math.abs(ramp.getCurrentPosition()) < target) {
            frontLeft.setPower(-power);
            backLeft.setPower(power);
            frontRight.setPower(power);
            backRight.setPower(-power);
        }
        stopDrive();
    }

    // Drive forward for encoder distance
    private void moveForwardTicks(int target, double power) {
        resetOdo();
        while (opModeIsActive() && Math.abs(intake.getCurrentPosition()) < target) {
            frontLeft.setPower(power);
            backLeft.setPower(power);
            frontRight.setPower(power);
            backRight.setPower(power);
        }
        stopDrive();
    }
}
